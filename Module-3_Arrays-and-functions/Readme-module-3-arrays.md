<!-- ===================================arrays-1============================================================ -->

Масиви
Масив — це впорядкована структура даних, яка використовується для зберігання колекції елементів.
Масиви можуть містити елементи різних типів даних, таких як числа, рядки, булеві значення тощо.

Для створення масиву в JavaScript використовується літерал масиву: квадратні дужки [].
Усередині дужок перераховуються елементи масиву, розділені комами. Ось приклад створення масиву:

const planets = ['Earth', 'Mars', 'Venus']; // масив рядків
const numbers = [1, 2, 3, 4, 5]; // масив чисел

Хоча в масивах зазвичай зберігаються однотипні дані, це не сувора вимога.
Масиви також можуть містити елементи різних типів даних.

const mixed = ['apple', 10, true]; // масив з елементами різних типів

Можна провести паралель з овочевим відділом у магазині, де різні види овочів зберігаються в окремих ящиках.
Наприклад, яблука можуть бути поміщені в один ящик, груші — в інший, апельсини — у третій і так далі.

Подібним чином у програмуванні використовуються масиви для групування однотипних елементів разом.
Усі елементи всередині масиву зазвичай мають один і той самий тип даних або структуру.

Вибери правильний синтаксис літерала масиву

<>
[]
{}
()
Результат

Абсолютно точно! У синтаксисі літерала масиву використовуються квадратні дужки.

<!-- ===================================arrays-2============================================================ -->

Доступ до елементів

Масив — це впорядкована колекція елементів, де кожен елемент має свій порядковий номер,
який називається індексом.
Індексація елементів масиву починається з нуля, тобто перший елемент має індекс 0, другий елемент — індекс 1 і так далі.

Щоб отримати доступ до значення елемента масиву, ми використовуємо синтаксис квадратних дужок:

arrayName[index]

Між іменем змінної, яка зберігає масив, і квадратними дужками не повинно бути пробілу.
Вказуємо індекс елемента всередині квадратних дужок.

const planets = ['Earth', 'Mars', 'Venus'];
console.log(planets[0]); // 'Earth'
console.log(planets[1]); // 'Mars'
console.log(planets[2]); // 'Venus'

У цьому прикладі ми створили масив рядків planets, що містить назви планет.
Потім ми звертаємося до елементів масиву, вказуючи відповідний індекс у квадратних дужках.

Результат звернення до елемента масиву можна зберегти у змінну і використовувати його надалі.

const planets = ['Earth', 'Mars', 'Venus'];
const firstElement = planets[0];
console.log(firstElement); // 'Earth'

Тепер значення першого елемента масиву 'Earth' збережено у змінній firstElement,
і ми можемо використовувати це значення для інших операцій або виразів у коді.

Спроба доступу до неіснуючого індексу поверне значення undefined.

const planets = ['Earth', 'Mars', 'Venus'];
console.log(planets[3]); // undefined
console.log(planets[999]); // undefined
Який індекс першого елемента масиву?

-1
0
1
Результат

Точно! Індексація елементів масиву починається з нуля!

<!-- ===================================arrays-3============================================================ -->

Перевизначення значення елемента

Елементи масиву можна змінювати, звернувшись до них за індексом і присвоївши нове значення.
Цей процес називається "перевизначенням" значення елемента.

Ось приклад, як перевизначити елементи масиву:

const planets = ['Earth', 'Mars', 'Venus', 'Uranus'];
planets[0] = 'Jupiter';
planets[2] = 'Neptune';
console.log(planets); // ['Jupiter', 'Mars', 'Neptune', 'Uranus']

У цьому прикладі ми створили змінну planets і помістили в неї масив, що містить назви планет.
Потім ми звернулися до елементів масиву за індексом і надали їм нові значення.

Важливо розуміти, що ми не змінили саму змінну planets, вона, як і раніше, містить масив.
Ми просто змінили значення всередині цього масиву.

Перевизначення елементів масиву дозволяє нам оновлювати дані та модифікувати масив під час виконання програми.
Це корисно, коли в нас є масив даних і ми хочемо змінити або оновити певне значення.

Вибери правильний синтаксис звернення до елемента масиву users з індексом 2

[2]users
users[2]
users.2
Результат

Саме так! Правильний синтаксис звернення до елемента масиву — це назва масиву та індекс елемента у квадратних дужках — users[2].

<!-- ===================================arrays-4============================================================ -->

Довжина масиву

Довжина масиву, тобто кількість його елементів, зберігається у властивості length.
Це динамічна величина, яка автоматично змінюється під час додавання або видалення елементів.

const planets = ['Earth', 'Mars', 'Venus'];
console.log(planets.length); // 3

У цьому прикладі в нас є масив planets із трьома елементами.
Вираз planets.length поверне значення 3, оскільки в масиві міститься три елементи.

Знання довжини масиву корисно, коли нам потрібно перевірити, скільки елементів у масиві на даний момент.

const planets = ['Earth', 'Mars', 'Venus'];

if(planets.length >= 3) {
console.log("3 or more elements");
} else {
console.log("3 or less elements");
}

<!-- ===================================arrays-5-arrays-6============================================================ -->

Індекс останнього елемента

Щоб знайти значення останнього елемента масиву, нам потрібно знати його індекс.
Індекс останнього елемента можна визначити за допомогою формули довжина_масиву -1.

Оскільки індексація елементів масиву починається з 0, а довжина масиву зберігає загальну кількість елементів,
віднімаючи 1 від довжини масиву, ми отримуємо індекс останнього елемента.

const planets = ["Earth", "Mars", "Venus"];
const lastElementIndex = planets.length - 1;
console.log(planets[lastElementIndex]); // "Venus"

У цьому прикладі маємо масив planets із трьома елементами.
Щоб отримати індекс останнього елемента масиву оголошується змінна lastElementIndex зі значенням planets.length - 1.
Маючи індекс останнього елемента в масиві, можемо отримати його значення за допомогою planets[lastElementIndex].

Такий підхід дозволяє отримати останній елемент масиву незалежно від його довжини. Це особливо корисно, коли ми не знаємо заздалегідь, скільки елементів міститиметься в масиві.

Як визначається індекс останнього елемента масиву?

Він завжди дорівнює значенню довжини масиву
Він завжди на одиницю менший за довжину масиву
Він завжди на одиницю більший за довжину масиву
Результат

І це правильна відповідь — індекс останнього елемента масиву на одиницю менше за довжину цього масиву.

<!-- =============================================================================================== -->

Присвоєння за посиланням і за значенням

Фундаментальною відмінністю складних типів від примітивів є те, як вони зберігаються і копіюються.

Примітиви: рядки, числа, буль, null і undefined, під час присвоювання копіюються цілком, за значенням (by value).

Зі складними типами все не так. У змінній, якій, наприклад, присвоєно масив, зберігаються не самі значення елементів масиву,
а адреса того місця в пам'яті, де цей масив розташовано. Іншими словами — посилання (покажчик) на нього.

Отже, вони передаються за посиланням (by reference).

Уявімо змінну у вигляді аркуша паперу. Її значення ми представимо у вигляді запису на цьому аркуші.

Якщо ми захочемо повідомити вміст цього запису користувачам, то можемо вчинити так — зробити фізичні копії і вручити їх кожному,
тобто зробити множинні незалежні копії (присвоєння за значенням).

Або помістити аркуш у зачиненій кімнаті й дати користувачам ключ від цієї кімнати,
тобто один екземпляр із загальним доступом (присвоєння за посиланням).

Тепер змінимо дані на аркуші паперу — значення змінної. Очевидно, що відвідувачі кімнати завжди бачитимуть зміни, які ми вносимо,
бо змінюється оригінал і вони мають до нього доступ. Власники паперових копій, навпаки, не помітять змін, дивлячись на свої копії.

Під час присвоєння за значенням змінним виділяється новий осередок пам'яті, і в нього копіюються дані.
Аналогія з множинними копіями паперового аркуша має цілком реальне втілення, окремий аркуш для кожної копії.

При присвоєнні за посиланням, замість створення нового значення, змінній присвоюється посилання (покажчик) на вже існуючий масив,
тобто на його місце в пам'яті. Таким чином, кілька змінних можуть вказувати на один і той самий масив, за аналогією із закритою кімнатою,
у користувачів є ключ доступу до оригіналу аркуша.

Усі примітивні типи присвоюються за значенням, тобто створюється копія.

let a = 5;

let b = a;
console.log(a); // 5
console.log(b); // 5
// Присвоєння за значенням, у пам'яті буде створено ще
// одну ячейку, в яку буде скопійовано значення 5

// Змінимо значення a
a = 10;
console.log(a); // 10
console.log(b); // 5 Значення b не змінилося, оскільки це окрема копія

Масиви (складний тип) присвоюються за посиланням, тобто змінна просто отримує посилання (покажчик у пам'яті) на вже існуючий масив.

const a = ["Mango", "Poly"];
const b = a;
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]

Оскільки a це масив, у b записується посилання на вже наявний у пам'яті масив. Тепер a і b вказують на один і той самий масив.

Змінимо масив, замінивши елемент з індексом 1, використовуючи посилання з a.

const a = ["Mango", "Poly"];
const b = a;
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]

a[1] = "Jacob";
console.log(a); // ["Mango", "Jacob"]
console.log(b); // ["Mango", "Jacob"]

Те, що зберігається в b, також змінилося, тому що b, як і a, просто містить посилання на одне й те саме місце в пам'яті — масив.

Результат повторюється, якщо використовувати посилання у змінній b для зміни масиву.

const a = ["Mango", "Poly"];
const b = a;
console.log(a); // ["Mango", "Poly"]
console.log(b); // ["Mango", "Poly"]

a[1] = "Jacob";
console.log(a); // ["Mango", "Jacob"]
console.log(b); // ["Mango", "Jacob"]

b[0] = "Ajax";
console.log(a); // ["Ajax", "Jacob"]
console.log(b); // ["Ajax", "Jacob"]

Два масиви ніколи не дорівнюють один одному, навіть якщо вони порожні або в них однакові елементи.

const arr1 = [1, 2, 3];
const arr2 = [1, 2, 3];

console.log(arr1 === arr2); // false
console.log([] === []); // false

У прикладах масиви містять однакові значення, але оператор === поверне false, тому що він перевіряє рівність посилань на масиви,
а не самих елементів усередині масивів. Це можна порівняти з тим, що змінні arr1 та arr2 посилаються на різні кімнати,
в яких різні папірці, але з однаковим вмістом.

Прочитай приклад коду

const arr1 = [1, 2, 3];
const arr2 = arr1;
arr1[1] = 1;
arr2[2] = 1;

Яким буде фінальне значення змінної arr2?

[1, 2, 3]
[1, 1, 1]
[1, 1, 3]

І це правильна відповідь — фінальне значення змінної arr2 буде [1, 1, 1].

Прочитай приклад коду

const arr1 = [1, 2, 3];
const arr2 = [1, 2, 3];
const result = arr1 === arr2;

Яким буде значення змінної result?

true
false
Результат

Саме так! У прикладі масиви містять однакові значення, але оператор === поверне false, 
тому що він перевіряє рівність посилань на масиви, а не самих елементів усередині масивів.

<!-- ========================================================================================================================================================== -->

Приведення типів: масиви

Явне і не явне приведення типів масивів здійснюється за необхідності виконати операції або порівняння, які вимагають сумісності типів даних.

Масив → Рядок

При перетворенні масиву в рядок усі елементи масиву об'єднуються в один рядок, розділений комами.

const array = [1, true, "Poly"];
console.log(String(array));// "1,true,Poly"
console.log(array + "5"); // "1,true,Poly5"

Масив → Число

При перетворенні масиву в число алгоритм складається з двох кроків:

спочатку масив приводиться до рядка,
а потім цей рядок приводиться до числового значення.

Наприклад, порожній масив приводиться до порожнього рядка, який приводиться до числа 0.

console.log(Number([])); // 0
console.log(Number([1])); // 1
console.log(Number([1, 2, 3])); // NaN

Масив → Логічне значення (буль)

При перетворенні масиву в логічне значення будь-який масив, навіть порожній, перетворюється на true.

const emptyArray = [];
const nonEmptyArray = [1, 2, 3];

console.log(Boolean(emptyArray)); // true
console.log(Boolean(nonEmptyArray)); // true

if(emptyArray) {
console.log("if is in progress")
} else {
console.log("else is not performed")
}

if(nonEmptyArray) {
console.log("if is in progress")
} else {
console.log("else is not performed")
}

Прочитай приклад коду

const array= [false];
const result = array ? "A" : "B";
Яким буде значення змінної result?

true
false
"A"
"B"

Саме так! У тернарному операторі значення змінної result, тобто масиву, перетворюється на логічне значення.
Будь-який масив перетворюється на true. Отже, виконається вираз тернарного оператора для істинної умови,
у змінну result буде присвоєно "A".
